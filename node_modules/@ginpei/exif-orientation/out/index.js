"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrientationInfo = exports.updateOrientationCode = exports.readOrientationCode = exports.getOrientation = exports.OrientationCode = void 0;
var OrientationCode;
(function (OrientationCode) {
    OrientationCode[OrientationCode["original"] = 1] = "original";
    OrientationCode[OrientationCode["deg90"] = 6] = "deg90";
    OrientationCode[OrientationCode["deg180"] = 3] = "deg180";
    OrientationCode[OrientationCode["deg270"] = 8] = "deg270";
    OrientationCode[OrientationCode["flipped"] = 2] = "flipped";
    OrientationCode[OrientationCode["deg90Flipped"] = 5] = "deg90Flipped";
    OrientationCode[OrientationCode["deg180Flipped"] = 4] = "deg180Flipped";
    OrientationCode[OrientationCode["deg270Flipped"] = 7] = "deg270Flipped";
    OrientationCode[OrientationCode["unknown"] = -1] = "unknown";
})(OrientationCode = exports.OrientationCode || (exports.OrientationCode = {}));
const orientationInfoMap = {
    [OrientationCode.original]: { rotation: 0, flipped: false },
    [OrientationCode.deg90]: { rotation: 90, flipped: false },
    [OrientationCode.deg180]: { rotation: 180, flipped: false },
    [OrientationCode.deg270]: { rotation: 270, flipped: false },
    [OrientationCode.flipped]: { rotation: 0, flipped: true },
    [OrientationCode.deg90Flipped]: { rotation: 90, flipped: true },
    [OrientationCode.deg180Flipped]: { rotation: 180, flipped: true },
    [OrientationCode.deg270Flipped]: { rotation: 270, flipped: true },
};
// tslint:disable:object-literal-sort-keys
const statics = {
    jpeg: 0xffd8,
    exifMarker: 0xffe1,
    exifId: 0x45786966,
    orderLittleEndian: 0x4949,
    endianAssertion: 0x002a,
    ifdFieldCountLength: 2,
    orientationTag: 0x0112,
    offsets: {
        firstMarker: 2,
        segment: {
            marker: 0,
            length: 2,
            exifId: 4,
        },
        tiffHeader: {
            fromSegment: 10,
            byteOrder: 0,
            endianAssertion: 2,
            ifdOffset: 4,
        },
        ifd: {
            fromTiffHeader: -1,
            tag: 0,
            type: 2,
            count: 4,
            value: 8,
        },
    },
};
// tslint:enable:object-literal-sort-keys
function sleep(ms) {
    return new Promise((done) => setTimeout(done, ms));
}
/**
 * If the input is not JPEG file with Exif containing orientation information,
 * it returns `undefined`.
 * @param input JPEG file data.
 */
function getOrientation(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const code = yield readOrientationCode(input);
        const info = getOrientationInfo(code);
        return info;
    });
}
exports.getOrientation = getOrientation;
/**
 * @see http://www.cipa.jp/std/documents/j/DC-008-2012_J.pdf
 */
function readOrientationCode(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const view = yield prepareDataView(input);
        if (!isValidJpeg(view)) {
            return OrientationCode.unknown;
        }
        const segmentOffset = yield findExifSegmentOffset(view);
        if (segmentOffset < 0) {
            return OrientationCode.unknown;
        }
        const { littleEndian, orientationOffset } = getOrientationOffsetAndLittleEndian(view, segmentOffset);
        if (orientationOffset < 0) {
            console.warn('Rotation information was not found');
            return OrientationCode.unknown;
        }
        const orientation = readOrientationValueAt(view, orientationOffset, littleEndian);
        return orientation;
    });
}
exports.readOrientationCode = readOrientationCode;
function updateOrientationCode(input, orientation) {
    return __awaiter(this, void 0, void 0, function* () {
        const view = yield prepareDataView(input);
        if (!isValidJpeg(view)) {
            throw new Error('The File you are trying to update is not a jpeg');
        }
        const segmentOffset = yield findExifSegmentOffset(view);
        if (segmentOffset < 0) {
            throw new Error('The File you are trying to update has no exif data');
        }
        const { littleEndian, orientationOffset } = getOrientationOffsetAndLittleEndian(view, segmentOffset);
        setOrientationValueAt(view, orientationOffset, orientation, littleEndian);
    });
}
exports.updateOrientationCode = updateOrientationCode;
function getOrientationOffsetAndLittleEndian(view, segmentOffset) {
    const tiffHeaderOffset = segmentOffset + statics.offsets.tiffHeader.fromSegment;
    const littleEndian = isLittleEndian(view, tiffHeaderOffset);
    const ifdPosition = findIfdPosition(view, tiffHeaderOffset, littleEndian);
    const ifdFieldOffset = ifdPosition + statics.ifdFieldCountLength;
    const orientationOffset = findOrientationOffset(view, ifdFieldOffset, littleEndian);
    return { littleEndian, orientationOffset };
}
function prepareDataView(input) {
    return __awaiter(this, void 0, void 0, function* () {
        // To run on both browser and Node.js,
        // need to check constructors existences before checking instance
        let arrayBuffer;
        if (typeof File !== 'undefined' && input instanceof File) {
            arrayBuffer = yield readFile(input);
        }
        else if (typeof Buffer !== 'undefined' && input instanceof Buffer) {
            arrayBuffer = input.buffer;
        }
        else {
            arrayBuffer = input;
        }
        const view = new DataView(arrayBuffer);
        return view;
    });
}
function readFile(file) {
    return __awaiter(this, void 0, void 0, function* () {
        const arrayBuffer = yield new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsArrayBuffer(file);
        });
        return arrayBuffer;
    });
}
function isValidJpeg(view) {
    return view.byteLength >= 2 && view.getUint16(0, false) === statics.jpeg;
}
/**
 * Returns `-1` if not found.
 */
function findExifSegmentOffset(view) {
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            for (var _b = __asyncValues(iterateMarkerSegments(view)), _c; _c = yield _b.next(), !_c.done;) {
                const segmentPosition = _c.value;
                if (isExifSegment(view, segmentPosition)) {
                    assertExifSegment(view, segmentPosition);
                    return segmentPosition;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // not found
        return -1;
    });
}
function iterateMarkerSegments(view) {
    return __asyncGenerator(this, arguments, function* iterateMarkerSegments_1() {
        // APPx/Exif p.18, 19, 150
        // - marker (short) `0xffe1` = APP1
        // - length (short) of segment
        // - padding (short) `0x0000` if exif
        // - "EXIF" (char[4]) if exif
        // - content
        // (The doc describe APP1 have to lay next to the SOI,
        //  however, Photoshop renders a JPEG file that SOI is followed by APP0.)
        let segmentPosition = statics.offsets.firstMarker;
        while (true) {
            // just in case
            yield __await(sleep(1));
            yield yield __await(segmentPosition);
            const offsetLength = statics.offsets.segment.length;
            const length = offsetLength + view.getUint16(segmentPosition + offsetLength, false);
            segmentPosition += length;
            if (segmentPosition > view.byteLength) {
                console.warn('APP1 not found');
                return yield __await(-1);
            }
        }
    });
}
function isExifSegment(view, segmentPosition) {
    const marker = view.getUint16(segmentPosition + statics.offsets.segment.marker, false);
    return marker === statics.exifMarker;
}
function assertExifSegment(view, segmentPosition) {
    // p 150
    const id = view.getUint32(segmentPosition + statics.offsets.segment.exifId, false);
    if (id !== statics.exifId) {
        throw new Error('Segment marked as Exif does not have Exif identifier');
    }
}
function isLittleEndian(view, tiffHeaderOffset) {
    const endian = view.getUint16(tiffHeaderOffset + statics.offsets.tiffHeader.byteOrder, false);
    const littleEndian = endian === statics.orderLittleEndian;
    return littleEndian;
}
function findIfdPosition(view, tiffHeaderOffset, littleEndian) {
    // TIFF Header p.17
    // - byte order (short). `0x4949` = little, `0x4d4d` = big
    // - 42 (0x002a) (short)
    // - offset of IFD (long). Minimum is `0x00000008` (8).
    const endianAssertionValue = view.getUint16(tiffHeaderOffset + statics.offsets.tiffHeader.endianAssertion, littleEndian);
    if (endianAssertionValue !== statics.endianAssertion) {
        throw new Error(`Invalid JPEG format: littleEndian ${littleEndian}, assertion: 0x${endianAssertionValue}`);
    }
    const ifdDistance = view.getUint32(tiffHeaderOffset + statics.offsets.tiffHeader.ifdOffset, littleEndian);
    const ifdPosition = tiffHeaderOffset + ifdDistance;
    return ifdPosition;
}
function findOrientationOffset(view, ifdFieldOffset, littleEndian) {
    const fieldIterator = iterateIfdFields(view, ifdFieldOffset, littleEndian);
    for (const offset of fieldIterator) {
        const tag = view.getUint16(ifdFieldOffset + offset, littleEndian);
        if (tag === statics.orientationTag) {
            const orientationValueOffset = ifdFieldOffset + offset + statics.offsets.ifd.value;
            return orientationValueOffset;
        }
    }
    return -1;
}
function* iterateIfdFields(view, ifdFieldOffset, littleEndian) {
    // IFD p.23
    // - num of IFD fields (short)
    // - IFD:
    //   - tag (short)
    //   - type (short)
    //   - count (long)
    //   - value offset (long)
    // - IFD...
    const numOfIfdFields = view.getUint16(ifdFieldOffset, littleEndian);
    const fieldLength = 12;
    for (let i = 0; i < numOfIfdFields; i++) {
        const currentOffset = i * fieldLength;
        yield currentOffset;
    }
}
function readOrientationValueAt(view, offset, littleEndian) {
    const orientation = view.getUint16(offset, littleEndian);
    return orientation;
}
function setOrientationValueAt(view, offset, orientation, littleEndian) {
    view.setUint16(offset, orientation, littleEndian);
}
/**
 * Converts orientation code specified in Exif to readable information.
 * @param input JPEG file data.
 */
function getOrientationInfo(orientation) {
    return orientationInfoMap[orientation];
}
exports.getOrientationInfo = getOrientationInfo;
//# sourceMappingURL=index.js.map